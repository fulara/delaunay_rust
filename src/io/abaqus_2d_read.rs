use types::*;
use std::io::BufRead;
use std::io::BufReader;
use std::fs::File;
use std::io::Read;

pub fn load_2d_from_abaqus_format(path_to_file: &str) -> Result<Triangulation2, String> {
    let f = match File::open(path_to_file) {
        Ok(file) => file,
        Err(_) => return Err("failed to open file".to_owned())
    };

    let fbuf = BufReader::new(f);
    read_buff(fbuf)
}

fn read_buff<R: Read>(reader: BufReader<R>) -> Result<Triangulation2, String> {
    enum ParserState {
        BeforeNode,
        Nodes,
        Elements,
        AfterElements,
    };

    let mut state = ParserState::BeforeNode;

    let mut nodes: Vec<Point2> = vec![];
    let mut elements: Vec<Triangle> = vec![];

    for line in reader.lines() {
        match line {
            Ok(line) =>
                match state {
                    ParserState::BeforeNode => {
                        if line.contains("*Node") {
                            state = ParserState::Nodes;
                        }
                    },
                    ParserState::Nodes => {
                        if line.contains("Element") {
                            state = ParserState::Elements
                        } else {
                            let split_line: Vec<_> = line.trim().split(',').collect();

                            if split_line.len() != 3 {
                                return Err(format!("line '{}' is not valid for a Node line", line))
                            } else {
                                let x: f64 = split_line[1].trim().parse().unwrap();
                                let y: f64 = split_line[2].trim().parse().unwrap();

                                nodes.push(Point2::new(x, y));
                            }
                        }
                    }

                    ParserState::Elements => {
                        if line.contains("*") {
                            state = ParserState::AfterElements
                        } else {
                            let split_line: Vec<_> = line.trim().split(',').collect();

                            if split_line.len() != 4 {
                                return Err(format!("line '{}' is not valid for a elementLine line", line))
                            } else {
                                let n1 = split_line[1].trim().parse::<usize>().unwrap() - 1usize;
                                let n2 = split_line[2].trim().parse::<usize>().unwrap() - 1usize;
                                let n3 = split_line[3].trim().parse::<usize>().unwrap() - 1usize;

                                elements.push(Triangle::new(&nodes, N2Index(n1), N2Index(n2), N2Index(n3)));
                            }
                        }
                    }
                    _ => ()
                },
            _ => ()
        }
    }

    match state {
        ParserState::AfterElements | ParserState::Elements => Ok(Triangulation2::new_from_prebuilt_triangulation(nodes, elements)),
        _ => Err("failed to parse file".to_owned()),
    }
}


#[cfg(test)]
mod test {
    use super::read_buff;
    use std::io::BufReader;
    use types::N2Index;

    #[test]
    fn test() {
        let s =
        "*Heading
** Job name: 3G-V1 Model name: 3G-V1
** Generated by: Abaqus/CAE Version 6.8-1
*Preprint, echo=NO, model=NO, history=NO, contact=NO
**
** PARTS
**
*Part, name=PART-1
*Node
    1,	0,	123
    2,	422,	0
    3,	0,	367
*Element, type=CPE3
1,	1,	2,	3
";
        let reader = BufReader::new(s.as_bytes());
        match read_buff(reader) {
            Ok(tr) => {
                assert_eq!(3, tr.nodes().len());

                assert_eq!(0., tr.nodes()[0].x);
                assert_eq!(123., tr.nodes()[0].y);

                assert_eq!(422., tr.nodes()[1].x);
                assert_eq!(0., tr.nodes()[1].y);

                assert_eq!(0., tr.nodes()[2].x);
                assert_eq!(367., tr.nodes()[2].y);

                assert_eq!(1, tr.elements().len());
                assert_eq!(N2Index(0), tr.elements()[0].index_a());
                assert_eq!(N2Index(2), tr.elements()[0].index_b());
                assert_eq!(N2Index(1), tr.elements()[0].index_c());
            }
            Err(str) => panic!("Expected success here got err: '{}'", str)
        }
    }
}